## Purpose

Automatically tracks database changes via SQL triggers for synchronization, ensuring all local modifications are captured and synced to the server. Triggers also handle primary key generation, device ID population, and client timestamp management.

## Requirements

### Requirement: SQL Triggers and Drift ORM

SQL triggers SHALL use raw SQL as required by SQLite trigger syntax.

**Note**: SQL triggers run at the database level and require raw SQL syntax. However, application code that creates or manages triggers SHALL use Drift ORM where possible. The trigger definitions themselves must be raw SQL, but trigger management code (creating, dropping triggers) should use Drift's database connection methods for consistency. If Drift ORM cannot effectively manage triggers, raw SQL may be used.

### Requirement: Automatic Change Tracking Triggers

The SDK SHALL create SQL triggers on all user tables to automatically track changes for synchronization.

Triggers SHALL:

- Use `mtds_trigger_` prefix to avoid conflicts with user-defined triggers
- Include BEFORE INSERT triggers to generate primary keys and populate `mtds_device_id` and `mtds_client_ts`
- Include BEFORE UPDATE triggers to update `mtds_client_ts` and `mtds_device_id`
- Include AFTER INSERT triggers for insert tracking
- Include AFTER UPDATE triggers for update and soft delete tracking
- Read device ID from `mtds_state` table

#### Scenario: BEFORE INSERT trigger generates PK and populates columns

- **WHEN** a new row is inserted into any user table
- **THEN** BEFORE INSERT trigger SHALL:
  - Retrieve DeviceID from `mtds_state` WHERE Attribute = 'mtds:DeviceID'
  - Update `mtds:client_ts` in state table and get the returned numValue
  - Generate primary key using formula: `pk = ((((DeviceID << 16) + mtds_client_ts) & 0xFFFFFFFFFF) << 24) | (DeviceID & 0xFFFFFF)`
  - Set `NEW.pk` to the generated primary key
  - Set `NEW.mtds_device_id` to DeviceID
  - Set `NEW.mtds_client_ts` to the returned numValue from state table
- **AND** trigger SHALL use namespace `mtds_trigger_${tableName}_insert_before`
- **NOTE**: Primary keys must be generated by client; server should NOT have auto_increment

#### Scenario: BEFORE UPDATE trigger updates timestamps

- **WHEN** a row is updated in any user table
- **THEN** BEFORE UPDATE trigger SHALL:
  - Retrieve DeviceID from `mtds_state` WHERE Attribute = 'mtds:DeviceID'
  - Update `mtds:client_ts` in state table and get the returned numValue
  - Set `NEW.mtds_client_ts` to the returned numValue
  - Set `NEW.mtds_device_id` to DeviceID
- **AND** trigger SHALL use namespace `mtds_trigger_${tableName}_update_before`

#### Scenario: AFTER INSERT trigger logs change

- **WHEN** a new row is inserted into any user table
- **AND** the row's `mtds_device_id` matches current device ID
- **THEN** AFTER INSERT trigger SHALL log change to `mtds_change_log`
- **AND** trigger SHALL use namespace `mtds_trigger_${tableName}_insert`
- **AND** the change log entry SHALL include table name, record PK, device ID, action, and payload

#### Scenario: AFTER UPDATE trigger logs changes

- **WHEN** a row is updated in any user table
- **AND** `mtds_client_ts` changed or soft delete occurred (`mtds_delete_ts` set)
- **AND** the row's `mtds_device_id` matches current device ID
- **THEN** AFTER UPDATE trigger SHALL log change to `mtds_change_log`
- **AND** trigger SHALL use namespace `mtds_trigger_${tableName}_update`
- **AND** the trigger SHALL capture both `mtds_client_ts` and `mtds_server_ts` in the payload
- **AND** if `mtds_delete_ts` was set, the action SHALL be 'delete', otherwise 'update'

#### Scenario: Trigger namespace isolation

- **WHEN** user defines their own triggers
- **THEN** SDK triggers SHALL not conflict due to `mtds_trigger_` prefix
- **AND** user triggers SHALL not interfere with SDK triggers

### Requirement: Primary Key Generation in BEFORE INSERT

The SDK SHALL generate primary keys in BEFORE INSERT triggers using device ID and client timestamp.

Primary key generation SHALL:

- Retrieve DeviceID from state table via SQL (triggers require raw SQL)
- Retrieve/update client timestamp from state table via SQL with RETURNING clause (triggers require raw SQL)
- **NOTE**: SQL triggers must use raw SQL syntax, but application code managing triggers should use Drift ORM
- Generate PK using formula: `pk = ((((DeviceID << 16) + mtds_client_ts) & 0xFFFFFFFFFF) << 24) | (DeviceID & 0xFFFFFF)`
- Set `NEW.pk` to the generated value
- Ensure primary keys are unique and encode device ID and timestamp

#### Scenario: Primary key generation formula

- **WHEN** a row is inserted
- **THEN** BEFORE INSERT trigger SHALL:
  - Extract DeviceID (64-bit, use last 24 bits: `DeviceID & 0xFFFFFF`)
  - Get mtds_client_ts from state table update
  - Calculate: `mix40 = ((DeviceID << 16) + mtds_client_ts) & 0xFFFFFFFFFF`
  - Calculate: `pk = (mix40 << 24) | (DeviceID & 0xFFFFFF)`
  - Set `NEW.pk` to the calculated value

### Requirement: Device ID and Client Timestamp Population

The SDK SHALL automatically populate `mtds_device_id` and `mtds_client_ts` in BEFORE INSERT and BEFORE UPDATE triggers.

#### Scenario: Device ID and timestamp in BEFORE INSERT

- **WHEN** a row is inserted
- **THEN** BEFORE INSERT trigger SHALL:
  - Read DeviceID from `mtds_state` WHERE Attribute = 'mtds:DeviceID'
  - Update `mtds:client_ts` in state table and get numValue
  - Set `NEW.mtds_device_id` to DeviceID
  - Set `NEW.mtds_client_ts` to the returned numValue

#### Scenario: Device ID and timestamp in BEFORE UPDATE

- **WHEN** a row is updated
- **THEN** BEFORE UPDATE trigger SHALL:
  - Read DeviceID from `mtds_state` WHERE Attribute = 'mtds:DeviceID'
  - Update `mtds:client_ts` in state table and get numValue
  - Set `NEW.mtds_device_id` to DeviceID
  - Set `NEW.mtds_client_ts` to the returned numValue

### Requirement: Soft Delete Timestamp in Triggers

The SDK SHALL handle soft delete timestamps in triggers.

Soft delete handling SHALL:

- Set `mtds_delete_ts` to the same value as `mtds_client_ts` when soft deleting
- Update `mtds_device_id` to current device ID
- Log the soft delete to change log via AFTER UPDATE trigger

#### Scenario: Soft delete in trigger

- **WHEN** a record is soft deleted (mtds_delete_ts is set)
- **THEN** BEFORE UPDATE trigger SHALL:
  - Update `mtds:client_ts` in state table and get numValue
  - Set `NEW.mtds_client_ts` to the returned numValue
  - Set `NEW.mtds_delete_ts` to the same value as `mtds_client_ts`
  - Set `NEW.mtds_device_id` to current DeviceID
- **AND** AFTER UPDATE trigger SHALL log the soft delete to change log with action 'delete'
