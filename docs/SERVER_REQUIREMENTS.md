# Server-Side Requirements for MTDS Compliance

## Overview

This document outlines the server-side requirements for implementing MTDS (Multi-Tenant Data Synchronization) compatibility. The client SDK (mtds) expects the server to follow specific conventions for field naming, data structures, and unique constraints.

## Table of Contents

- [Field Naming Convention](#field-naming-convention)
- [Required Fields](#required-fields)
- [Database Schema Requirements](#database-schema-requirements)
- [Unique Index Requirements](#unique-index-requirements)
- [API Endpoints](#api-endpoints)
- [Sync Protocol](#sync-protocol)
- [Soft-Delete Handling](#soft-delete-handling)
- [Error Handling](#error-handling)

---

## Field Naming Convention

### MTDS Namespace Prefix

All special-purpose fields used by the MTDS protocol **MUST** be prefixed with `mtds_` to avoid conflicts with user-defined fields.

**Required Prefix:** `mtds_`

### Why Use Prefixes?

- **Prevents Naming Conflicts**: User tables can have any field names without collision
- **Clear Ownership**: Immediately identifies MTDS system fields
- **Easy Filtering**: Server logic can easily identify special fields
- **Convention Consistency**: Client and server use same naming

---

## Required Fields

All replicated tables **MUST** include the following MTDS fields:

### 1. `mtds_last_updated_txid` (INTEGER, NOT NULL)

**Purpose:** Transaction ID representing when the record was last modified

**Type:** 64-bit integer (BIGINT)

**Value:** Nanoseconds since Unix epoch

**Usage:**

- Generated by client using `MtdsUtils.generateTxid()` or `sdk.generateTxid()`
- Used for conflict resolution (higher value wins)
- Used for incremental sync queries

**Example:**

```sql
mtds_last_updated_txid BIGINT NOT NULL DEFAULT 0
```

### 2. `mtds_device_id` (INTEGER, NOT NULL)

**Purpose:** Identifies which device created/modified the record

**Type:** 48-bit integer (can fit in BIGINT)

**Value:** Device identifier (0 to 281,474,976,710,655)

**Usage:**

- Tracks record origin
- Prevents sync loops
- Audit trail

**Example:**

```sql
mtds_device_id BIGINT NOT NULL DEFAULT 0
```

### 3. `mtds_deleted_txid` (INTEGER, NULLABLE)

**Purpose:** Marks records for soft-deletion

**Type:** 64-bit integer (BIGINT), nullable

**Value:**

- `NULL` = Record is active
- `<timestamp>` = Record marked for deletion

**Usage:**

- Soft-delete workflow
- Allows replication before deletion
- Prevents unique constraint violations

**Example:**

```sql
mtds_deleted_txid BIGINT NULL
```

---

## Database Schema Requirements

### Complete Table Example

```sql
CREATE TABLE users (
    -- User-defined fields
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- MTDS required fields
    mtds_last_updated_txid BIGINT NOT NULL DEFAULT 0,
    mtds_device_id BIGINT NOT NULL DEFAULT 0,
    mtds_deleted_txid BIGINT NULL,

    -- Indexes (see Unique Index Requirements section)
    UNIQUE INDEX idx_users_email (email, mtds_deleted_txid)
);
```

### Field Constraints

| Field                  | Type   | Nullable | Default | Notes                    |
| ---------------------- | ------ | -------- | ------- | ------------------------ |
| `mtds_last_updated_txid` | BIGINT | NO       | 0       | Always updated on change |
| `mtds_device_id`        | BIGINT | NO       | -       | Set by client            |
| `mtds_deleted_txid`     | BIGINT | YES      | NULL    | NULL = active record     |

### Index Recommendations

```sql
-- Performance: Query by last update time
CREATE INDEX idx_mtds_lastUpdated ON users(mtds_last_updated_txid);

-- Performance: Filter active records
CREATE INDEX idx_mtds_active ON users(mtds_deleted_txid)
WHERE mtds_deleted_txid IS NULL;

-- Audit: Track by device
CREATE INDEX idx_mtds_device ON users(mtds_device_id);
```

---

## Unique Index Requirements

### Critical: Include Soft-Delete Marker

**IMPORTANT:** All unique indexes **MUST** include `mtds_deleted_txid` to prevent unique constraint violations after soft-deletion.

### Why?

When a record is soft-deleted (`mtds_deleted_txid` is set), users should be able to create a new record with the same unique value. Without including `mtds_deleted_txid` in the unique constraint, this would fail.

### Example Problem

**Wrong Approach:**

```sql
-- ❌ BAD: Will prevent reusing email after soft-delete
CREATE UNIQUE INDEX idx_users_email ON users(email);
```

**Scenario:**

1. User creates account: `email='john@example.com', mtds_deleted_txid=NULL`
2. User deletes account: `email='john@example.com', mtds_deleted_txid=1234567890`
3. User tries to re-register with same email
4. **ERROR**: Unique constraint violation (email already exists)

**Correct Approach:**

```sql
-- ✅ GOOD: Allows reusing email after soft-delete
CREATE UNIQUE INDEX idx_users_email ON users(email, mtds_deleted_txid);
```

**Scenario:**

1. User creates account: `email='john@example.com', mtds_deleted_txid=NULL`
2. User deletes account: `email='john@example.com', mtds_deleted_txid=1234567890`
3. User re-registers: `email='john@example.com', mtds_deleted_txid=NULL`
4. **SUCCESS**: Different `mtds_deleted_txid` values = unique constraint satisfied

### More Examples

```sql
-- Email uniqueness (including soft-deletes)
CREATE UNIQUE INDEX idx_users_email
ON users(email, mtds_deleted_txid);

-- Username uniqueness
CREATE UNIQUE INDEX idx_users_username
ON users(username, mtds_deleted_txid);

-- Product SKU uniqueness
CREATE UNIQUE INDEX idx_products_sku
ON products(sku, mtds_deleted_txid);

-- Composite uniqueness (e.g., email + tenant)
CREATE UNIQUE INDEX idx_users_email_tenant
ON users(email, tenant_id, mtds_deleted_txid);
```

### Database-Specific Syntax

**PostgreSQL:**

```sql
CREATE UNIQUE INDEX idx_users_email
ON users(email, mtds_deleted_txid);
```

**MySQL:**

```sql
CREATE UNIQUE INDEX idx_users_email
ON users(email, mtds_deleted_txid);
```

**SQLite:**

```sql
CREATE UNIQUE INDEX idx_users_email
ON users(email, mtds_deleted_txid);
```

**SQL Server:**

```sql
CREATE UNIQUE INDEX idx_users_email
ON users(email, mtds_deleted_txid);
```

---

## API Endpoints

### 1. Sync Endpoint (Receive Updates from Clients)

**Endpoint:** `POST /mtdd/sync/changes`

**Purpose:** Receive change log entries from clients with hybrid timestamp support

**Request Body:**

```json
{
  "changes": [
    {
      "clientTxid": 1731493200000000000,
      "table_name": "users",
      "record_pk": 123,
      "mtds_device_id": 12345,
      "action": 0,
      "payload": {
        "New": {
          "id": 123,
          "email": "john@example.com",
          "name": "John Doe",
          "mtds_last_updated_txid": 1731493200000000000,
          "mtds_device_id": 12345,
          "mtds_deleted_txid": null
        },
        "old": null
      }
    }
  ]
}
```

**Action Codes:**

- `0` = INSERT
- `1` = UPDATE
- `null` = SOFT DELETE

**Response (UPDATED - Includes Server Timestamps):**

```json
{
  "success": true,
  "updates": [
    {
      "clientTxid": 1731493200000000000,
      "serverTxid": 1731500000000000000,
      "tableName": "users",
      "pk": 123
    }
  ]
}
```

**Server Logic (UPDATED - Hybrid Timestamps):**

```javascript
// Pseudo-code with hybrid timestamp support
app.post('/sync', async (req, res) => {
  const changes = req.body.changes;
  const results = [];
  
  // Sort by clientTxid to preserve operation order
  changes.sort((a, b) => a.clientTxid - b.clientTxid);
  
  for (const change of changes) {
    // ✅ SERVER generates authoritative timestamp
    const serverTxid = Date.now() * 1000000 + process.hrtime()[1];
    
    // Optional: Detect clock skew
    const skewMs = Math.abs(serverTxid - change.clientTxid) / 1000000;
    if (skewMs > 60000) {
      console.warn(`Clock skew: ${skewMs}ms for device ${change.mtds_device_id}`);
    }
    
    if (change.action === 0 || change.action === 1) {
      // INSERT or UPDATE
      const payload = change.payload.New;
      
      // Override with server timestamp
      payload.mtds_last_updated_txid = serverTxid;
      
      await db(change.table_name)
        .insert(payload)
        .onConflict('id')
        .merge();  // Upsert
        
      results.push({
        clientTxid: change.clientTxid,
        serverTxid: serverTxid,
        tableName: change.table_name,
        pk: change.record_pk
      });
    } else if (change.action === null) {
      // SOFT DELETE
      await db(change.table_name)
        .where({ id: change.record_pk })
        .update({ 
          mtds_deleted_txid: serverTxid,
          mtds_last_updated_txid: serverTxid
        });
        
      results.push({
        clientTxid: change.clientTxid,
        serverTxid: serverTxid,
        tableName: change.table_name,
        pk: change.record_pk
      });
    }
    
    // Broadcast to other clients via SSE
    sseManager.broadcast({
      table: change.table_name,
      data: payload,
      excludeDeviceId: change.mtds_device_id
    });
  }
  
  res.json({ 
    success: true, 
    updates: results  // ← Client uses this to update local timestamps
  });
});
```

### 2. Data Sync Endpoint (Send Data to Clients)

**Endpoint:** `GET /api/data` (or `/sync/data`)

**Purpose:** Provide incremental data updates to clients

**Query Parameters:**

- `tableName` (required) - Name of table to sync
- `lastUpdated` (required) - Client's last sync timestamp
- `deviceId` (required) - Client's device ID

**Example Request:**

```
GET /api/data?tableName=users&lastUpdated=1234567890&deviceId=12345
```

**Response:**

```json
[
  {
    "id": 123,
    "email": "john@example.com",
    "name": "John Doe",
    "mtds_last_updated_txid": 1234567890123456789,
    "mtds_device_id": 12345,
    "mtds_deleted_txid": null
  },
  {
    "id": 124,
    "email": "jane@example.com",
    "name": "Jane Smith",
    "mtds_last_updated_txid": 1234567890123456790,
    "mtds_device_id": 67890,
    "mtds_deleted_txid": null
  }
]
```

**Server Query (SQL):**

```sql
SELECT * FROM users
WHERE mtds_last_updated_txid > :lastUpdated
  AND mtds_device_id != :deviceId
ORDER BY mtds_last_updated_txid ASC
LIMIT 1000;
```

**Important Filters:**

1. `mtds_last_updated_txid > :lastUpdated` - Only new/updated records
2. `mtds_device_id != :deviceId` - Exclude client's own changes (prevent loops)
3. Optional: `mtds_deleted_txid IS NULL` - Exclude soft-deleted records (or include them for cleanup)

### 3. Server-Sent Events (SSE) Endpoint

**Endpoint:** `GET /mtdd/events`

**Purpose:** Real-time push notifications for data changes

**Headers:**

- `Authorization: Bearer <token>`
- `deviceId: <device_id>`

**Event Format:**

```
event: message
data: {"table":"users","data":{...record...}}
```

**Example Event:**

```javascript
{
  "table": "users",
  "data": {
    "id": 125,
    "email": "new@example.com",
    "name": "New User",
    "mtds_last_updated_txid": 1234567890123456791,
    "mtds_device_id": 99999,
    "mtds_deleted_txid": null
  }
}
```

---

## Sync Protocol

### Incremental Sync Flow

```
┌─────────────────────────────────────────────────────────────┐
│  1. Client tracks max mtds_last_updated_txid per table       │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  2. Client sends: GET /api/data?tableName=X&lastUpdated=T  │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  3. Server queries records where mtds_last_updated_txid > T  │
│     AND mtds_device_id != client's device                   │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  4. Server returns records with all mtds_ fields           │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  5. Client inserts/updates records (conflict resolution)   │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  6. Client updates max mtds_last_updated_txid                │
└─────────────────────────────────────────────────────────────┘
```

### Conflict Resolution

**Rule:** Highest `mtds_last_updated_txid` wins (Last Write Wins - LWW)

**Server Logic:**

```javascript
async function handleUpdate(table, newRecord, pk) {
  const existing = await db.findOne(table, {id: pk});

  if (!existing) {
    // New record, insert
    await db.insert(table, newRecord);
    return;
  }

  if (newRecord.mtds_last_updated_txid > existing.mtds_last_updated_txid) {
    // Newer version, update
    await db.update(table, newRecord, {id: pk});
  } else {
    // Older version, ignore
    console.log(`Ignoring older update for ${table}:${pk}`);
  }
}
```

---

## Soft-Delete Handling

### Server-Side Soft-Delete Process

```
┌─────────────────────────────────────────────────────────────┐
│  1. Client marks record: mtds_deleted_txid = <timestamp>    │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  2. Client syncs to server (Action = null)                 │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  3. Server updates: SET mtds_deleted_txid = <timestamp>     │
│     WHERE id = <pk>                                         │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  4. Server replicates to all other devices                 │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  5. Server KEEPS record in database (soft-deleted)         │
│     (Optional: Garbage collection after retention period)   │
└─────────────────────────────────────────────────────────────┘
```

### Server Query Patterns

**Get Active Records:**

```sql
SELECT * FROM users
WHERE mtds_deleted_txid IS NULL;
```

**Get All Records (including deleted):**

```sql
SELECT * FROM users;
```

**Get Recently Deleted:**

```sql
SELECT * FROM users
WHERE mtds_deleted_txid IS NOT NULL
  AND mtds_deleted_txid > :since_timestamp;
```

### Garbage Collection (Optional)

After a retention period, server may permanently delete soft-deleted records:

```sql
DELETE FROM users
WHERE mtds_deleted_txid IS NOT NULL
  AND mtds_deleted_txid < (UNIX_TIMESTAMP() - 30*24*60*60*1000000000); -- 30 days in nanoseconds
```

**Recommendation:** Keep soft-deleted records for at least 30-90 days for:

- Audit purposes
- Data recovery
- Sync for offline devices

---

## Error Handling

### Common Errors and Responses

**1. Unique Constraint Violation**

```json
{
  "success": false,
  "error": "UNIQUE_CONSTRAINT_VIOLATION",
  "message": "Email already exists",
  "field": "email",
  "code": 409
}
```

**2. Timestamp Conflict (Older Update)**

```json
{
  "success": true,
  "warning": "UPDATE_IGNORED",
  "message": "Record has newer version on server",
  "code": 200
}
```

**3. Missing MTDS Fields**

```json
{
  "success": false,
  "error": "MISSING_REQUIRED_FIELD",
  "message": "mtds_device_id is required",
  "field": "mtds_device_id",
  "code": 400
}
```

**4. Invalid DeviceID**

```json
{
  "success": false,
  "error": "INVALID_DEVICE_ID",
  "message": "DeviceID exceeds 48-bit limit",
  "code": 400
}
```

---

## Implementation Checklist

### Database Schema

- [ ] Add `mtds_last_updated_txid BIGINT NOT NULL` to all replicated tables
- [ ] Add `mtds_device_id BIGINT NOT NULL` to all replicated tables
- [ ] Add `mtds_deleted_txid BIGINT NULL` to all replicated tables
- [ ] Update all unique indexes to include `mtds_deleted_txid`
- [ ] Add performance indexes on `mtds_last_updated_txid`

### API Endpoints

- [ ] Implement `POST /update` for receiving client changes
- [ ] Implement `GET /api/data` for incremental sync
- [ ] Implement `GET /mtdd/events` for SSE real-time updates
- [ ] Add authentication and device ID validation
- [ ] Add rate limiting and pagination

### Business Logic

- [ ] Implement conflict resolution (LWW based on `mtds_last_updated_txid`)
- [ ] Handle soft-deletes (set `mtds_deleted_txid`, don't hard delete)
- [ ] Filter out requesting device's own changes in sync responses
- [ ] Implement garbage collection for old soft-deleted records
- [ ] Add logging and monitoring for sync operations

### Security

- [ ] Validate JWT tokens and extract tenant ID
- [ ] Enforce tenant isolation in queries
- [ ] Validate DeviceID is within 48-bit range
- [ ] Implement rate limiting per device
- [ ] Add audit logging for all changes

### Testing

- [ ] Test unique constraint with soft-deletes
- [ ] Test conflict resolution scenarios
- [ ] Test incremental sync with various timestamp ranges
- [ ] Test SSE connection and reconnection
- [ ] Test with multiple concurrent clients

---

## Example Server Implementation (Node.js)

```javascript
const express = require('express');
const app = express();

app.post('/update', async (req, res) => {
  const changes = req.body;
  const results = [];

  for (const change of changes) {
    try {
      if (change.Action === 0) {
        // INSERT
        await db(change.TableName).insert(change.PayLoad.New);
      } else if (change.Action === 1) {
        // UPDATE with conflict resolution
        const existing = await db(change.TableName)
          .where({id: change.PK})
          .first();

        if (!existing || change.TXID > existing.mtds_last_updated_txid) {
          await db(change.TableName)
            .where({id: change.PK})
            .update(change.PayLoad.New);
        }
      } else if (change.Action === null) {
        // SOFT DELETE
        await db(change.TableName)
          .where({id: change.PK})
          .update({mtds_deleted_txid: change.TXID});
      }

      results.push({success: true, record: change.PK});
    } catch (error) {
      results.push({success: false, record: change.PK, error: error.message});
    }
  }

  res.json({success: true, results});
});

app.get('/api/data', async (req, res) => {
  const {tableName, lastUpdated, deviceId} = req.query;

  const records = await db(tableName)
    .where('mtds_last_updated_txid', '>', lastUpdated)
    .whereNot('mtds_device_id', deviceId)
    .orderBy('mtds_last_updated_txid', 'asc')
    .limit(1000);

  res.json(records);
});
```

---

## Support and Questions

For implementation questions or issues, please refer to:

- Client SDK Documentation: `README.md`
- Phase Documentation: `PHASE1_CHANGES.md` through `PHASE4_CHANGES.md`
- GitHub Issues: [Repository URL]

---

## Version History

| Version | Date | Changes                          |
| ------- | ---- | -------------------------------- |
| 1.0.0   | 2024 | Initial MTDS server requirements |
