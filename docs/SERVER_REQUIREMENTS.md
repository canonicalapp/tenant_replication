# Server-Side Requirements for MTDS Compliance

## Overview

This document outlines the server-side requirements for implementing MTDS (Multi-Tenant Data Synchronization) compatibility. The client SDK (tenant_replication) expects the server to follow specific conventions for field naming, data structures, and unique constraints.

## Table of Contents

- [Field Naming Convention](#field-naming-convention)
- [Required Fields](#required-fields)
- [Database Schema Requirements](#database-schema-requirements)
- [Unique Index Requirements](#unique-index-requirements)
- [API Endpoints](#api-endpoints)
- [Sync Protocol](#sync-protocol)
- [Soft-Delete Handling](#soft-delete-handling)
- [Error Handling](#error-handling)

---

## Field Naming Convention

### MTDS Namespace Prefix

All special-purpose fields used by the MTDS protocol **MUST** be prefixed with `mtds_` to avoid conflicts with user-defined fields.

**Required Prefix:** `mtds_`

### Why Use Prefixes?

- **Prevents Naming Conflicts**: User tables can have any field names without collision
- **Clear Ownership**: Immediately identifies MTDS system fields
- **Easy Filtering**: Server logic can easily identify special fields
- **Convention Consistency**: Client and server use same naming

---

## Required Fields

All replicated tables **MUST** include the following MTDS fields:

### 1. `mtds_lastUpdatedTxid` (INTEGER, NOT NULL)

**Purpose:** Transaction ID representing when the record was last modified

**Type:** 64-bit integer (BIGINT)

**Value:** Nanoseconds since Unix epoch

**Usage:**

- Generated by client using `DBHelper.generateTxid()`
- Used for conflict resolution (higher value wins)
- Used for incremental sync queries

**Example:**

```sql
mtds_lastUpdatedTxid BIGINT NOT NULL DEFAULT 0
```

### 2. `mtds_DeviceID` (INTEGER, NOT NULL)

**Purpose:** Identifies which device created/modified the record

**Type:** 48-bit integer (can fit in BIGINT)

**Value:** Device identifier (0 to 281,474,976,710,655)

**Usage:**

- Tracks record origin
- Prevents sync loops
- Audit trail

**Example:**

```sql
mtds_DeviceID BIGINT NOT NULL
```

### 3. `mtds_DeletedTXID` (INTEGER, NULLABLE)

**Purpose:** Marks records for soft-deletion

**Type:** 64-bit integer (BIGINT), nullable

**Value:**

- `NULL` = Record is active
- `<timestamp>` = Record marked for deletion

**Usage:**

- Soft-delete workflow
- Allows replication before deletion
- Prevents unique constraint violations

**Example:**

```sql
mtds_DeletedTXID BIGINT NULL
```

---

## Database Schema Requirements

### Complete Table Example

```sql
CREATE TABLE users (
    -- User-defined fields
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- MTDS required fields
    mtds_lastUpdatedTxid BIGINT NOT NULL DEFAULT 0,
    mtds_DeviceID BIGINT NOT NULL,
    mtds_DeletedTXID BIGINT NULL,

    -- Indexes (see Unique Index Requirements section)
    UNIQUE INDEX idx_users_email (email, mtds_DeletedTXID)
);
```

### Field Constraints

| Field                  | Type   | Nullable | Default | Notes                    |
| ---------------------- | ------ | -------- | ------- | ------------------------ |
| `mtds_lastUpdatedTxid` | BIGINT | NO       | 0       | Always updated on change |
| `mtds_DeviceID`        | BIGINT | NO       | -       | Set by client            |
| `mtds_DeletedTXID`     | BIGINT | YES      | NULL    | NULL = active record     |

### Index Recommendations

```sql
-- Performance: Query by last update time
CREATE INDEX idx_mtds_lastUpdated ON users(mtds_lastUpdatedTxid);

-- Performance: Filter active records
CREATE INDEX idx_mtds_active ON users(mtds_DeletedTXID)
WHERE mtds_DeletedTXID IS NULL;

-- Audit: Track by device
CREATE INDEX idx_mtds_device ON users(mtds_DeviceID);
```

---

## Unique Index Requirements

### Critical: Include Soft-Delete Marker

**IMPORTANT:** All unique indexes **MUST** include `mtds_DeletedTXID` to prevent unique constraint violations after soft-deletion.

### Why?

When a record is soft-deleted (`mtds_DeletedTXID` is set), users should be able to create a new record with the same unique value. Without including `mtds_DeletedTXID` in the unique constraint, this would fail.

### Example Problem

**Wrong Approach:**

```sql
-- ❌ BAD: Will prevent reusing email after soft-delete
CREATE UNIQUE INDEX idx_users_email ON users(email);
```

**Scenario:**

1. User creates account: `email='john@example.com', mtds_DeletedTXID=NULL`
2. User deletes account: `email='john@example.com', mtds_DeletedTXID=1234567890`
3. User tries to re-register with same email
4. **ERROR**: Unique constraint violation (email already exists)

**Correct Approach:**

```sql
-- ✅ GOOD: Allows reusing email after soft-delete
CREATE UNIQUE INDEX idx_users_email ON users(email, mtds_DeletedTXID);
```

**Scenario:**

1. User creates account: `email='john@example.com', mtds_DeletedTXID=NULL`
2. User deletes account: `email='john@example.com', mtds_DeletedTXID=1234567890`
3. User re-registers: `email='john@example.com', mtds_DeletedTXID=NULL`
4. **SUCCESS**: Different `mtds_DeletedTXID` values = unique constraint satisfied

### More Examples

```sql
-- Email uniqueness (including soft-deletes)
CREATE UNIQUE INDEX idx_users_email
ON users(email, mtds_DeletedTXID);

-- Username uniqueness
CREATE UNIQUE INDEX idx_users_username
ON users(username, mtds_DeletedTXID);

-- Product SKU uniqueness
CREATE UNIQUE INDEX idx_products_sku
ON products(sku, mtds_DeletedTXID);

-- Composite uniqueness (e.g., email + tenant)
CREATE UNIQUE INDEX idx_users_email_tenant
ON users(email, tenant_id, mtds_DeletedTXID);
```

### Database-Specific Syntax

**PostgreSQL:**

```sql
CREATE UNIQUE INDEX idx_users_email
ON users(email, mtds_DeletedTXID);
```

**MySQL:**

```sql
CREATE UNIQUE INDEX idx_users_email
ON users(email, mtds_DeletedTXID);
```

**SQLite:**

```sql
CREATE UNIQUE INDEX idx_users_email
ON users(email, mtds_DeletedTXID);
```

**SQL Server:**

```sql
CREATE UNIQUE INDEX idx_users_email
ON users(email, mtds_DeletedTXID);
```

---

## API Endpoints

### 1. Sync Endpoint (Receive Updates from Clients)

**Endpoint:** `POST /update` (or `/api/sync/update`)

**Purpose:** Receive change log entries from clients

**Request Body:**

```json
[
  {
    "TXID": 1234567890123456789,
    "TableName": "users",
    "PK": 123,
    "mtds_DeviceID": 12345,
    "Action": 0,
    "PayLoad": {
      "New": {
        "id": 123,
        "email": "john@example.com",
        "name": "John Doe",
        "mtds_lastUpdatedTxid": 1234567890123456789,
        "mtds_DeviceID": 12345,
        "mtds_DeletedTXID": null
      },
      "old": null
    }
  }
]
```

**Action Codes:**

- `0` = INSERT
- `1` = UPDATE
- `null` = SOFT DELETE

**Response:**

```json
{
  "success": true,
  "processed": 1,
  "errors": []
}
```

**Server Logic:**

```javascript
// Pseudo-code
for (const change of changes) {
  if (change.Action === 0) {
    // INSERT
    await db.insert(change.TableName, change.PayLoad.New);
  } else if (change.Action === 1) {
    // UPDATE
    await db.update(change.TableName, change.PayLoad.New, {
      where: {id: change.PK},
    });
  } else if (change.Action === null) {
    // SOFT DELETE - Mark as deleted
    await db.update(
      change.TableName,
      {
        mtds_DeletedTXID: change.TXID,
      },
      {
        where: {id: change.PK},
      }
    );
  }
}
```

### 2. Data Sync Endpoint (Send Data to Clients)

**Endpoint:** `GET /api/data` (or `/sync/data`)

**Purpose:** Provide incremental data updates to clients

**Query Parameters:**

- `tableName` (required) - Name of table to sync
- `lastUpdated` (required) - Client's last sync timestamp
- `deviceId` (required) - Client's device ID

**Example Request:**

```
GET /api/data?tableName=users&lastUpdated=1234567890&deviceId=12345
```

**Response:**

```json
[
  {
    "id": 123,
    "email": "john@example.com",
    "name": "John Doe",
    "mtds_lastUpdatedTxid": 1234567890123456789,
    "mtds_DeviceID": 12345,
    "mtds_DeletedTXID": null
  },
  {
    "id": 124,
    "email": "jane@example.com",
    "name": "Jane Smith",
    "mtds_lastUpdatedTxid": 1234567890123456790,
    "mtds_DeviceID": 67890,
    "mtds_DeletedTXID": null
  }
]
```

**Server Query (SQL):**

```sql
SELECT * FROM users
WHERE mtds_lastUpdatedTxid > :lastUpdated
  AND mtds_DeviceID != :deviceId
ORDER BY mtds_lastUpdatedTxid ASC
LIMIT 1000;
```

**Important Filters:**

1. `mtds_lastUpdatedTxid > :lastUpdated` - Only new/updated records
2. `mtds_DeviceID != :deviceId` - Exclude client's own changes (prevent loops)
3. Optional: `mtds_DeletedTXID IS NULL` - Exclude soft-deleted records (or include them for cleanup)

### 3. Server-Sent Events (SSE) Endpoint

**Endpoint:** `GET /mtdd/events`

**Purpose:** Real-time push notifications for data changes

**Headers:**

- `Authorization: Bearer <token>`
- `deviceId: <device_id>`

**Event Format:**

```
event: message
data: {"table":"users","data":{...record...}}
```

**Example Event:**

```javascript
{
  "table": "users",
  "data": {
    "id": 125,
    "email": "new@example.com",
    "name": "New User",
    "mtds_lastUpdatedTxid": 1234567890123456791,
    "mtds_DeviceID": 99999,
    "mtds_DeletedTXID": null
  }
}
```

---

## Sync Protocol

### Incremental Sync Flow

```
┌─────────────────────────────────────────────────────────────┐
│  1. Client tracks max mtds_lastUpdatedTxid per table       │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  2. Client sends: GET /api/data?tableName=X&lastUpdated=T  │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  3. Server queries records where mtds_lastUpdatedTxid > T  │
│     AND mtds_DeviceID != client's device                   │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  4. Server returns records with all mtds_ fields           │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  5. Client inserts/updates records (conflict resolution)   │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  6. Client updates max mtds_lastUpdatedTxid                │
└─────────────────────────────────────────────────────────────┘
```

### Conflict Resolution

**Rule:** Highest `mtds_lastUpdatedTxid` wins (Last Write Wins - LWW)

**Server Logic:**

```javascript
async function handleUpdate(table, newRecord, pk) {
  const existing = await db.findOne(table, {id: pk});

  if (!existing) {
    // New record, insert
    await db.insert(table, newRecord);
    return;
  }

  if (newRecord.mtds_lastUpdatedTxid > existing.mtds_lastUpdatedTxid) {
    // Newer version, update
    await db.update(table, newRecord, {id: pk});
  } else {
    // Older version, ignore
    console.log(`Ignoring older update for ${table}:${pk}`);
  }
}
```

---

## Soft-Delete Handling

### Server-Side Soft-Delete Process

```
┌─────────────────────────────────────────────────────────────┐
│  1. Client marks record: mtds_DeletedTXID = <timestamp>    │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  2. Client syncs to server (Action = null)                 │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  3. Server updates: SET mtds_DeletedTXID = <timestamp>     │
│     WHERE id = <pk>                                         │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  4. Server replicates to all other devices                 │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  5. Server KEEPS record in database (soft-deleted)         │
│     (Optional: Garbage collection after retention period)   │
└─────────────────────────────────────────────────────────────┘
```

### Server Query Patterns

**Get Active Records:**

```sql
SELECT * FROM users
WHERE mtds_DeletedTXID IS NULL;
```

**Get All Records (including deleted):**

```sql
SELECT * FROM users;
```

**Get Recently Deleted:**

```sql
SELECT * FROM users
WHERE mtds_DeletedTXID IS NOT NULL
  AND mtds_DeletedTXID > :since_timestamp;
```

### Garbage Collection (Optional)

After a retention period, server may permanently delete soft-deleted records:

```sql
DELETE FROM users
WHERE mtds_DeletedTXID IS NOT NULL
  AND mtds_DeletedTXID < (UNIX_TIMESTAMP() - 30*24*60*60*1000000000); -- 30 days in nanoseconds
```

**Recommendation:** Keep soft-deleted records for at least 30-90 days for:

- Audit purposes
- Data recovery
- Sync for offline devices

---

## Error Handling

### Common Errors and Responses

**1. Unique Constraint Violation**

```json
{
  "success": false,
  "error": "UNIQUE_CONSTRAINT_VIOLATION",
  "message": "Email already exists",
  "field": "email",
  "code": 409
}
```

**2. Timestamp Conflict (Older Update)**

```json
{
  "success": true,
  "warning": "UPDATE_IGNORED",
  "message": "Record has newer version on server",
  "code": 200
}
```

**3. Missing MTDS Fields**

```json
{
  "success": false,
  "error": "MISSING_REQUIRED_FIELD",
  "message": "mtds_DeviceID is required",
  "field": "mtds_DeviceID",
  "code": 400
}
```

**4. Invalid DeviceID**

```json
{
  "success": false,
  "error": "INVALID_DEVICE_ID",
  "message": "DeviceID exceeds 48-bit limit",
  "code": 400
}
```

---

## Implementation Checklist

### Database Schema

- [ ] Add `mtds_lastUpdatedTxid BIGINT NOT NULL` to all replicated tables
- [ ] Add `mtds_DeviceID BIGINT NOT NULL` to all replicated tables
- [ ] Add `mtds_DeletedTXID BIGINT NULL` to all replicated tables
- [ ] Update all unique indexes to include `mtds_DeletedTXID`
- [ ] Add performance indexes on `mtds_lastUpdatedTxid`

### API Endpoints

- [ ] Implement `POST /update` for receiving client changes
- [ ] Implement `GET /api/data` for incremental sync
- [ ] Implement `GET /mtdd/events` for SSE real-time updates
- [ ] Add authentication and device ID validation
- [ ] Add rate limiting and pagination

### Business Logic

- [ ] Implement conflict resolution (LWW based on `mtds_lastUpdatedTxid`)
- [ ] Handle soft-deletes (set `mtds_DeletedTXID`, don't hard delete)
- [ ] Filter out requesting device's own changes in sync responses
- [ ] Implement garbage collection for old soft-deleted records
- [ ] Add logging and monitoring for sync operations

### Security

- [ ] Validate JWT tokens and extract tenant ID
- [ ] Enforce tenant isolation in queries
- [ ] Validate DeviceID is within 48-bit range
- [ ] Implement rate limiting per device
- [ ] Add audit logging for all changes

### Testing

- [ ] Test unique constraint with soft-deletes
- [ ] Test conflict resolution scenarios
- [ ] Test incremental sync with various timestamp ranges
- [ ] Test SSE connection and reconnection
- [ ] Test with multiple concurrent clients

---

## Example Server Implementation (Node.js)

```javascript
const express = require('express');
const app = express();

app.post('/update', async (req, res) => {
  const changes = req.body;
  const results = [];

  for (const change of changes) {
    try {
      if (change.Action === 0) {
        // INSERT
        await db(change.TableName).insert(change.PayLoad.New);
      } else if (change.Action === 1) {
        // UPDATE with conflict resolution
        const existing = await db(change.TableName)
          .where({id: change.PK})
          .first();

        if (!existing || change.TXID > existing.mtds_lastUpdatedTxid) {
          await db(change.TableName)
            .where({id: change.PK})
            .update(change.PayLoad.New);
        }
      } else if (change.Action === null) {
        // SOFT DELETE
        await db(change.TableName)
          .where({id: change.PK})
          .update({mtds_DeletedTXID: change.TXID});
      }

      results.push({success: true, record: change.PK});
    } catch (error) {
      results.push({success: false, record: change.PK, error: error.message});
    }
  }

  res.json({success: true, results});
});

app.get('/api/data', async (req, res) => {
  const {tableName, lastUpdated, deviceId} = req.query;

  const records = await db(tableName)
    .where('mtds_lastUpdatedTxid', '>', lastUpdated)
    .whereNot('mtds_DeviceID', deviceId)
    .orderBy('mtds_lastUpdatedTxid', 'asc')
    .limit(1000);

  res.json(records);
});
```

---

## Support and Questions

For implementation questions or issues, please refer to:

- Client SDK Documentation: `README.md`
- Phase Documentation: `PHASE1_CHANGES.md` through `PHASE4_CHANGES.md`
- GitHub Issues: [Repository URL]

---

## Version History

| Version | Date | Changes                          |
| ------- | ---- | -------------------------------- |
| 1.0.0   | 2024 | Initial MTDS server requirements |
